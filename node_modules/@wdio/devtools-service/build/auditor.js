"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _diagnostics = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/diagnostics"));

var _mainthreadWorkBreakdown = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/mainthread-work-breakdown"));

var _metrics = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics"));

var _serverResponseTime = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/server-response-time"));

var _cumulativeLayoutShift = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics/cumulative-layout-shift"));

var _firstContentfulPaint = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics/first-contentful-paint"));

var _largestContentfulPaint = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics/largest-contentful-paint"));

var _speedIndex = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics/speed-index"));

var _interactive = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics/interactive"));

var _totalBlockingTime = _interopRequireDefault(require("lighthouse/lighthouse-core/audits/metrics/total-blocking-time"));

var _scoring = _interopRequireDefault(require("lighthouse/lighthouse-core/scoring"));

var _defaultConfig = _interopRequireDefault(require("lighthouse/lighthouse-core/config/default-config"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('@wdio/devtools-service:Auditor');
const SHARED_AUDIT_CONTEXT = {
  settings: {
    throttlingMethod: 'devtools'
  },
  LighthouseRunWarnings: false,
  computedCache: new Map()
};

class Auditor {
  constructor(traceLogs, devtoolsLogs) {
    this.devtoolsLogs = devtoolsLogs;
    this.traceLogs = traceLogs;
    this.url = traceLogs.pageUrl;
    this.loaderId = traceLogs.loaderId;
  }

  _audit(AUDIT, params = {}) {
    const auditContext = _objectSpread({
      options: _objectSpread({}, AUDIT.defaultOptions)
    }, SHARED_AUDIT_CONTEXT);

    try {
      return AUDIT.audit(_objectSpread({
        traces: {
          defaultPass: this.traceLogs
        },
        devtoolsLogs: {
          defaultPass: this.devtoolsLogs
        },
        TestedAsMobileDevice: true
      }, params), auditContext);
    } catch (e) {
      log.error(e);
      return {};
    }
  }

  updateCommands(browser, customFn) {
    const commands = Object.getOwnPropertyNames(Object.getPrototypeOf(this)).filter(fnName => fnName !== 'constructor' && fnName !== 'updateCommands' && !fnName.startsWith('_'));
    commands.forEach(fnName => browser.addCommand(fnName, customFn || this[fnName].bind(this)));
  }

  async getMainThreadWorkBreakdown() {
    const result = await this._audit(_mainthreadWorkBreakdown.default);
    return result.details.items.map(({
      group,
      duration
    }) => ({
      group,
      duration
    }));
  }

  async getDiagnostics() {
    const result = await this._audit(_diagnostics.default);

    if (!Object.prototype.hasOwnProperty.call(result, 'details')) {
      return null;
    }

    return result.details.items[0];
  }

  async getMetrics() {
    const serverResponseTime = await this._audit(_serverResponseTime.default, {
      URL: this.url
    });
    const cumulativeLayoutShift = await this._audit(_cumulativeLayoutShift.default);
    const result = await this._audit(_metrics.default);
    const metrics = result.details.items[0] || {};
    return {
      estimatedInputLatency: metrics.estimatedInputLatency,
      timeToFirstByte: Math.round(serverResponseTime.numericValue, 10),
      serverResponseTime: Math.round(serverResponseTime.numericValue, 10),
      domContentLoaded: metrics.observedDomContentLoaded,
      firstVisualChange: metrics.observedFirstVisualChange,
      firstPaint: metrics.observedFirstPaint,
      firstContentfulPaint: metrics.firstContentfulPaint,
      firstMeaningfulPaint: metrics.firstMeaningfulPaint,
      largestContentfulPaint: metrics.largestContentfulPaint,
      lastVisualChange: metrics.observedLastVisualChange,
      firstCPUIdle: metrics.firstCPUIdle,
      firstInteractive: metrics.interactive,
      load: metrics.observedLoad,
      speedIndex: metrics.speedIndex,
      totalBlockingTime: metrics.totalBlockingTime,
      cumulativeLayoutShift: cumulativeLayoutShift.numericValue
    };
  }

  async getPerformanceScore() {
    const auditResults = {};
    auditResults['speed-index'] = await this._audit(_speedIndex.default);
    auditResults['first-contentful-paint'] = await this._audit(_firstContentfulPaint.default);
    auditResults['largest-contentful-paint'] = await this._audit(_largestContentfulPaint.default);
    auditResults['cumulative-layout-shift'] = await this._audit(_cumulativeLayoutShift.default);
    auditResults['total-blocking-time'] = await this._audit(_totalBlockingTime.default);
    auditResults.interactive = await this._audit(_interactive.default);

    if (!auditResults.interactive || !auditResults['cumulative-layout-shift'] || !auditResults['first-contentful-paint'] || !auditResults['largest-contentful-paint'] || !auditResults['speed-index'] || !auditResults['total-blocking-time']) {
      log.info('One or multiple required metrics couldn\'t be found, setting performance score to: null');
      return null;
    }

    const scores = _defaultConfig.default.categories.performance.auditRefs.filter(auditRef => auditRef.weight).map(auditRef => ({
      score: auditResults[auditRef.id].score,
      weight: auditRef.weight
    }));

    return _scoring.default.arithmeticMean(scores);
  }

}

exports.default = Auditor;