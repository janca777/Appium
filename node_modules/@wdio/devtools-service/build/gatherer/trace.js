"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("core-js/modules/web.url");

var _events = _interopRequireDefault(require("events"));

var _networkRecorder = _interopRequireDefault(require("lighthouse/lighthouse-core/lib/network-recorder"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _registerPerformanceObserverInPage = _interopRequireDefault(require("../scripts/registerPerformanceObserverInPage"));

var _checkTimeSinceLastLongTask = _interopRequireDefault(require("../scripts/checkTimeSinceLastLongTask"));

var _constants = require("../constants");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const log = (0, _logger.default)('@wdio/devtools-service:TraceGatherer');
const NETWORK_RECORDER_EVENTS = ['Network.requestWillBeSent', 'Network.requestServedFromCache', 'Network.responseReceived', 'Network.dataReceived', 'Network.loadingFinished', 'Network.loadingFailed', 'Network.resourceChangedPriority'];

class TraceGatherer extends _events.default {
  constructor(session, page) {
    super();
    this.session = session;
    this.page = page;
    this.networkListeners = {};
    this.failingFrameLoadIds = [];
    this.pageLoadDetected = false;
    NETWORK_RECORDER_EVENTS.forEach(method => {
      this.networkListeners[method] = params => this.networkStatusMonitor.dispatch({
        method,
        params
      });
    });
  }

  async startTracing(url) {
    delete this.trace;
    this.networkStatusMonitor = new _networkRecorder.default();
    NETWORK_RECORDER_EVENTS.forEach(method => {
      this.session.on(method, this.networkListeners[method]);
    });
    this.traceStart = Date.now();
    log.info(`Start tracing frame with url ${url}`);
    await this.page.tracing.start({
      categories: _constants.DEFAULT_TRACING_CATEGORIES,
      screenshots: true
    });

    if (url === 'click event') {
      log.info('Start checking for page load for click');
      this.clickTraceTimeout = setTimeout(async () => {
        log.info('No page load detected, canceling trace');
        await this.page.tracing.stop();
        return this.finishTracing();
      }, _constants.FRAME_LOAD_START_TIMEOUT);
    }

    await this.page.evaluateOnNewDocument(_registerPerformanceObserverInPage.default);
    this.waitForNetworkIdleEvent = this.waitForNetworkIdle(this.session);
    this.waitForCPUIdleEvent = this.waitForCPUIdle();
  }

  async onFrameNavigated(msgObj) {
    if (!this.isTracing) {
      return;
    }

    if (this.failingFrameLoadIds.includes(msgObj.frame.id)) {
      delete this.traceStart;
      this.waitForNetworkIdleEvent.cancel();
      this.waitForCPUIdleEvent.cancel();
      this.frameId = '"unsuccessful loaded frame"';
      this.finishTracing();
      this.emit('tracingError', new Error(`Page with url "${msgObj.frame.url}" failed to load`));
      return clearTimeout(this.clickTraceTimeout);
    }

    if (this.frameId || msgObj.frame.parentId || !(0, _utils.isSupportedUrl)(msgObj.frame.url)) {
      log.info(`Ignore navigated frame with url ${msgObj.frame.url}`);
      return;
    }

    this.frameId = msgObj.frame.id;
    this.loaderId = msgObj.frame.loaderId;
    this.pageUrl = msgObj.frame.url;
    log.info(`Page load detected: ${this.pageUrl}, set frameId ${this.frameId}, set loaderId ${this.loaderId}`);

    if (this.clickTraceTimeout && !this.pageLoadDetected) {
      log.info('Page load detected for click, clearing click trace timeout}');
      this.pageLoadDetected = true;
      clearTimeout(this.clickTraceTimeout);
    }

    this.emit('tracingStarted', msgObj.frame.id);
  }

  async onLoadEventFired() {
    if (!this.isTracing) {
      return;
    }

    const loadPromise = Promise.all([this.waitForNetworkIdleEvent.promise, this.waitForCPUIdleEvent.promise]).then(() => async () => {
      const minTraceTime = _constants.TRACING_TIMEOUT - (Date.now() - this.traceStart);

      if (minTraceTime > 0) {
        log.info(`page load happen to quick, waiting ${minTraceTime}ms more`);
        await new Promise(resolve => setTimeout(resolve, minTraceTime));
      }

      return this.completeTracing();
    });
    const cleanupFn = await Promise.race([loadPromise, this.waitForMaxTimeout()]);
    this.waitForNetworkIdleEvent.cancel();
    this.waitForCPUIdleEvent.cancel();
    return cleanupFn();
  }

  onFrameLoadFail(request) {
    const frame = request.frame();
    this.failingFrameLoadIds.push(frame._id);
  }

  get isTracing() {
    return typeof this.traceStart === 'number';
  }

  async completeTracing() {
    const traceDuration = Date.now() - this.traceStart;
    log.info(`Tracing completed after ${traceDuration}ms, capturing performance data for frame ${this.frameId}`);

    try {
      const traceBuffer = await this.page.tracing.stop();
      const traceEvents = JSON.parse(traceBuffer.toString('utf8'));
      const startedInBrowserEvt = traceEvents.traceEvents.find(e => e.name === 'TracingStartedInBrowser');
      const mainFrame = startedInBrowserEvt && startedInBrowserEvt.args && startedInBrowserEvt.args.data.frames && startedInBrowserEvt.args.data.frames.find(frame => !frame.parent);

      if (mainFrame && mainFrame.processId) {
        const threadNameEvt = traceEvents.traceEvents.find(e => e.ph === 'R' && e.cat === 'blink.user_timing' && e.name === 'navigationStart' && e.args.data.isLoadingMainFrame);

        if (threadNameEvt) {
          log.info(`Replace mainFrame process id ${mainFrame.processId} with actual thread process id ${threadNameEvt.pid}`);
          mainFrame.processId = threadNameEvt.pid;
        } else {
          log.info(`Couldn't replace mainFrame process id ${mainFrame.processId} with actual thread process id`);
        }
      }

      this.trace = _objectSpread(_objectSpread({}, traceEvents), {}, {
        frameId: this.frameId,
        loaderId: this.loaderId,
        pageUrl: this.pageUrl,
        traceStart: this.traceStart,
        traceEnd: Date.now()
      });
      this.emit('tracingComplete', this.trace);
      this.finishTracing();
    } catch (err) {
      log.error(`Error capturing tracing logs: ${err.stack}`);
      this.emit('tracingError', err);
      return this.finishTracing();
    }
  }

  finishTracing() {
    log.info(`Tracing for ${this.frameId} completed`);
    this.pageLoadDetected = false;
    NETWORK_RECORDER_EVENTS.forEach(method => this.session.removeListener(method, this.networkListeners[method]));
    delete this.networkStatusMonitor;
    delete this.traceStart;
    delete this.frameId;
    delete this.loaderId;
    delete this.pageUrl;
    this.failingFrameLoadIds = [];
    this.waitForNetworkIdleEvent.cancel();
    this.waitForCPUIdleEvent.cancel();
    this.emit('tracingFinished');
  }

  waitForNetworkIdle(session, networkQuietThresholdMs = _constants.NETWORK_IDLE_TIMEOUT) {
    let hasDCLFired = false;
    let idleTimeout;

    let cancel = () => {
      throw new Error('_waitForNetworkIdle.cancel() called before it was defined');
    };

    if (!this.networkStatusMonitor) {
      throw new Error('TraceGatherer.waitForNetworkIdle called with no networkStatusMonitor');
    }

    const networkStatusMonitor = this.networkStatusMonitor;
    const promise = new Promise(resolve => {
      const onIdle = () => {
        networkStatusMonitor.once('network-2-busy', onBusy);
        idleTimeout = setTimeout(() => {
          log.info('Network became finally idle');
          cancel();
          resolve();
        }, networkQuietThresholdMs);
      };

      const onBusy = () => {
        networkStatusMonitor.once('network-2-idle', onIdle);
        idleTimeout && clearTimeout(idleTimeout);
      };

      const domContentLoadedListener = () => {
        hasDCLFired = true;
        networkStatusMonitor.is2Idle() ? onIdle() : onBusy();
      };

      const logStatus = () => {
        if (!hasDCLFired) {
          return log.info('Waiting on DomContentLoaded');
        }

        const inflightRecords = networkStatusMonitor.getInflightRecords();
        log.info(`Found ${inflightRecords.length} inflight network records`);

        if (inflightRecords.length < 10) {
          for (const record of inflightRecords) {
            log.info(`Waiting on ${record.url.slice(0, 120)} to finish`);
          }
        }
      };

      networkStatusMonitor.on('requeststarted', logStatus);
      networkStatusMonitor.on('requestloaded', logStatus);
      networkStatusMonitor.on('network-2-busy', logStatus);
      session.once('Page.domContentEventFired', domContentLoadedListener);
      let canceled = false;

      cancel = () => {
        if (canceled) return;
        canceled = true;
        log.info('Wait for network idle canceled');
        idleTimeout && clearTimeout(idleTimeout);
        session.removeListener('Page.domContentEventFired', domContentLoadedListener);
        networkStatusMonitor.removeListener('network-2-busy', onBusy);
        networkStatusMonitor.removeListener('network-2-idle', onIdle);
        networkStatusMonitor.removeListener('requeststarted', logStatus);
        networkStatusMonitor.removeListener('requestloaded', logStatus);
        networkStatusMonitor.removeListener('network-2-busy', logStatus);
      };
    });
    return {
      promise,
      cancel
    };
  }

  waitForCPUIdle(waitForCPUIdle = _constants.CPU_IDLE_TRESHOLD) {
    if (!waitForCPUIdle) {
      return {
        promise: Promise.resolve(),
        cancel: () => undefined
      };
    }

    let lastTimeout;
    let canceled = false;
    const checkForQuietExpression = `(${_checkTimeSinceLastLongTask.default.toString()})()`;

    async function checkForQuiet(resolve, reject) {
      if (canceled) return;
      let timeSinceLongTask;

      try {
        timeSinceLongTask = (await this.page.evaluate(checkForQuietExpression)) || 0;
      } catch (e) {
        log.warn(`Page evaluate rejected while evaluating checkForQuietExpression: ${e.stack}`);
        return setTimeout(() => checkForQuiet.call(this, resolve, reject), 100);
      }

      if (canceled) return;

      if (typeof timeSinceLongTask !== 'number') {
        log.warn(`unexpected value for timeSinceLongTask: ${timeSinceLongTask}`);
        return reject(new Error('timeSinceLongTask is not a number'));
      }

      log.info('Driver', `CPU has been idle for ${timeSinceLongTask} ms`);

      if (timeSinceLongTask >= waitForCPUIdle) {
        return resolve();
      }

      const timeToWait = waitForCPUIdle - timeSinceLongTask;
      lastTimeout = setTimeout(() => checkForQuiet.call(this, resolve, reject), timeToWait);
    }

    let cancel = () => {
      throw new Error('_waitForCPUIdle.cancel() called before it was defined');
    };

    const promise = new Promise((resolve, reject) => {
      log.info('Waiting for CPU to become idle');
      checkForQuiet.call(this, resolve, reject);

      cancel = () => {
        if (canceled) return;
        canceled = true;
        if (lastTimeout) clearTimeout(lastTimeout);
        resolve(new Error('Wait for CPU idle canceled'));
      };
    });
    return {
      promise,
      cancel
    };
  }

  waitForMaxTimeout(maxWaitForLoadedMs = _constants.MAX_TRACE_WAIT_TIME) {
    return new Promise(resolve => setTimeout(resolve, maxWaitForLoadedMs)).then(() => async () => {
      log.error('Neither network nor CPU idle time could be detected within timeout, wrapping up tracing');
      return this.completeTracing();
    });
  }

}

exports.default = TraceGatherer;