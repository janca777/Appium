"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exitHookFn = exports.runner = void 0;

var _asyncExitHook = _interopRequireDefault(require("async-exit-hook"));

var _runner = _interopRequireDefault(require("@wdio/runner"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/local-runner');
const runner = new _runner.default();
exports.runner = runner;
runner.on('exit', process.exit.bind(process));
runner.on('error', ({
  name,
  message,
  stack
}) => process.send({
  origin: 'worker',
  name: 'error',
  content: {
    name,
    message,
    stack
  }
}));
process.on('message', m => {
  if (!m || !m.command) {
    return;
  }

  log.info(`Run worker command: ${m.command}`);
  runner[m.command](m).then(result => process.send({
    origin: 'worker',
    name: 'finisedCommand',
    content: {
      command: m.command,
      result
    }
  }), e => {
    log.error(`Failed launching test session: ${e.stack}`);
    process.exit(1);
  });
});

const exitHookFn = callback => {
  if (!callback) {
    return;
  }

  runner.sigintWasCalled = true;
  log.info(`Received SIGINT, giving process ${_constants.SHUTDOWN_TIMEOUT}ms to shutdown gracefully`);
  setTimeout(callback, _constants.SHUTDOWN_TIMEOUT);
};

exports.exitHookFn = exitHookFn;
(0, _asyncExitHook.default)(exitHookFn);